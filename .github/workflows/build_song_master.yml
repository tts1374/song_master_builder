name: Song Master CI

"on":
  pull_request:
    branches: [main]
  push:
    branches: [main]
  schedule:
    # 毎週日曜 18:00 UTC (月曜 03:00 JST)
    - cron: "0 18 * * 0"
  workflow_dispatch:
    inputs:
      publish:
        description: "成果物を公開する（手動実行時のみ）"
        required: false
        default: false
        type: boolean

permissions:
  contents: write

jobs:
  pr-lightweight:
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run lightweight tests
        run: |
          pytest -q -m "light"

  full-validate:
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Prepare baseline sqlite (latest release or bootstrap)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python - <<'PY'
          import json
          import os
          import pathlib
          import sqlite3
          import yaml
          from src.github_release import get_latest_release, find_asset_by_name, download_asset

          def write_env(name: str, value: str):
              with open(os.environ["GITHUB_ENV"], "a", encoding="utf-8") as env_file:
                  env_file.write(f"{name}={value}\n")

          def create_empty_baseline(path: pathlib.Path):
              conn = sqlite3.connect(str(path))
              try:
                  cur = conn.cursor()
                  cur.execute(
                      """
                      CREATE TABLE IF NOT EXISTS music (
                          music_id INTEGER PRIMARY KEY AUTOINCREMENT,
                          textage_id TEXT NOT NULL UNIQUE
                      );
                      """
                  )
                  cur.execute(
                      """
                      CREATE TABLE IF NOT EXISTS chart (
                          chart_id INTEGER PRIMARY KEY AUTOINCREMENT,
                          music_id INTEGER NOT NULL,
                          play_style TEXT NOT NULL,
                          difficulty TEXT NOT NULL,
                          UNIQUE(music_id, play_style, difficulty),
                          FOREIGN KEY(music_id) REFERENCES music(music_id)
                      );
                      """
                  )
                  conn.commit()
              finally:
                  conn.close()

          settings = yaml.safe_load(pathlib.Path("settings.yaml").read_text(encoding="utf-8"))
          owner = settings["github"]["owner"]
          repo = settings["github"]["repo"]
          token = os.environ["GITHUB_TOKEN"]
          fallback_asset_name = settings.get("github", {}).get("asset_name")

          out_dir = pathlib.Path("baseline")
          out_dir.mkdir(parents=True, exist_ok=True)
          baseline_sqlite = out_dir / "baseline.sqlite"

          release = get_latest_release(f"{owner}/{repo}", token)
          selected_asset = None
          selected_name = None

          if release is not None:
              latest_asset = find_asset_by_name(release, "latest.json")
              if latest_asset is not None:
                  latest_path = out_dir / "latest.json"
                  download_asset(latest_asset, str(latest_path), token=token)
                  manifest = json.loads(latest_path.read_text(encoding="utf-8"))
                  file_name = manifest.get("file_name")
                  if file_name:
                      manifest_asset = find_asset_by_name(release, file_name)
                      if manifest_asset is not None:
                          selected_asset = manifest_asset
                          selected_name = file_name

              if selected_asset is None and fallback_asset_name:
                  fallback_asset = find_asset_by_name(release, fallback_asset_name)
                  if fallback_asset is not None:
                      selected_asset = fallback_asset
                      selected_name = fallback_asset_name

              if selected_asset is None:
                  sqlite_assets = [
                      asset for asset in release.get("assets", [])
                      if str(asset.get("name", "")).lower().endswith(".sqlite")
                  ]
                  if sqlite_assets:
                      sqlite_assets.sort(key=lambda a: a.get("updated_at") or "", reverse=True)
                      selected_asset = sqlite_assets[0]
                      selected_name = str(selected_asset.get("name", "baseline.sqlite"))

          if selected_asset is not None:
              download_asset(selected_asset, str(baseline_sqlite), token=token)
              write_env("BASELINE_BOOTSTRAP", "0")
              print(f"baseline source: release asset ({selected_name})")
          else:
              create_empty_baseline(baseline_sqlite)
              write_env("BASELINE_BOOTSTRAP", "1")
              print("baseline source: bootstrap empty sqlite (first run)")

          write_env("BASELINE_SQLITE_PATH", str(baseline_sqlite.resolve()))
          PY

      - name: Disable publish during verification phase
        env:
          BASELINE_BOOTSTRAP: ${{ env.BASELINE_BOOTSTRAP }}
        run: |
          python - <<'PY'
          import os
          import pathlib
          import yaml

          settings_path = pathlib.Path("settings.yaml")
          settings = yaml.safe_load(settings_path.read_text(encoding="utf-8"))
          github_cfg = settings.setdefault("github", {})
          github_cfg["upload_to_release"] = False
          settings["chart_id_missing_policy"] = "warn"
          if os.environ.get("BASELINE_BOOTSTRAP") == "1":
              github_cfg["require_previous_release"] = False
              print("bootstrap mode enabled: require_previous_release=false")
          settings_path.write_text(yaml.safe_dump(settings, allow_unicode=True, sort_keys=False), encoding="utf-8")
          PY

      - name: Build artifacts (no publish)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          python main.py

      - name: Run full tests
        env:
          CI: "true"
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BASELINE_SQLITE_PATH: ${{ env.BASELINE_SQLITE_PATH }}
        run: |
          pytest -q -m "full"

      - name: Create draft date-tag release with artifacts
        if: github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && github.event.inputs.publish == 'true')
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          python - <<'PY'
          import json
          import os
          import pathlib
          import yaml
          from src.discord_notify import send_discord_message
          from src.github_release import publish_files_as_new_date_release

          settings = yaml.safe_load(pathlib.Path("settings.yaml").read_text(encoding="utf-8"))
          owner = settings["github"]["owner"]
          repo = settings["github"]["repo"]
          output_db_path = settings.get("output_db_path", "song_master.sqlite")
          output_base = pathlib.Path(output_db_path)
          output_dir = output_base.parent if str(output_base.parent) not in {"", "."} else pathlib.Path(".")

          latest_path = output_dir / "latest.json"
          if not latest_path.exists():
              print(f"skip publish: latest.json が未生成です ({latest_path})")
              print("build が skip された可能性があるため、公開処理をスキップします。")
              raise SystemExit(0)

          manifest = json.loads(latest_path.read_text(encoding="utf-8"))
          sqlite_name = manifest.get("file_name")
          if not sqlite_name:
              raise RuntimeError("公開失敗: latest.json に file_name がありません")

          sqlite_path = output_dir / sqlite_name
          if not sqlite_path.exists():
              raise RuntimeError(f"公開失敗: SQLite が存在しません: {sqlite_name}")

          release_notes = "\n".join(
              [
                  "## Draft release (manual publish required)",
                  "",
                  "- tag: {tag} (YYYY-MM-DD or YYYY-MM-DD.N)",
                  f"- schema_version: {manifest.get('schema_version', '')}",
                  f"- generated_at: {manifest.get('generated_at', '')}",
                  f"- sha256: {manifest.get('sha256', '')}",
                  f"- byte_size: {manifest.get('byte_size', '')}",
                  "",
                  "This draft is created by GitHub Actions. Publish from GitHub UI after validation.",
              ]
          )

          release = publish_files_as_new_date_release(
              repo=f"{owner}/{repo}",
              token=os.environ["GITHUB_TOKEN"],
              file_paths=[str(sqlite_path), str(latest_path)],
              generated_at=str(manifest.get("generated_at") or ""),
              draft=True,
              release_body_template=release_notes,
          )

          release_url = str(release.get("html_url", ""))
          release_tag = str(release.get("tag_name", ""))
          generated_at = str(manifest.get("generated_at", ""))
          sha256 = str(manifest.get("sha256", ""))

          print(f"draft release created: tag={release_tag} url={release_url}")

          webhook = os.environ.get("DISCORD_WEBHOOK_URL")
          if webhook:
              send_discord_message(
                  webhook,
                  "\n".join(
                      [
                          "song master draft release created",
                          f"- release_url: {release_url}",
                          f"- tag: {release_tag}",
                          f"- generated_at: {generated_at}",
                          f"- sha256: {sha256}",
                      ]
                  ),
              )
          PY

      - name: Notify weekly failure
        if: failure() && github.event_name == 'schedule'
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          python - <<'PY'
          import os
          from src.discord_notify import send_discord_message

          webhook = os.environ.get("DISCORD_WEBHOOK_URL")
          if webhook:
              send_discord_message(webhook, "song master weekly full validation failed")
          PY
